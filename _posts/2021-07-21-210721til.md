---
layout: single
title:"2021.07.21 TIL"
---

## 버전 관리

### VCS (Version Control System)

: VCS 를 사용하면 각 파일을 이전 상태로 되돌릴 수 있고, 프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를 일으켰는지도 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다.
VCS 를 사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다.

### 버전 관리 방법

#### 로컬 버전 관리)

: 많은 사람들이 사용하는 방법 중 하나로
버전을 관리하기 위해 디렉토리로 파일을 복사하는 방법을 쓴다.
**( 디렉토리 이름에 시간을 기록해주면 좋다.)**
이 방법은 간단하지만 잘못되기도 쉽다.

이런 이유로 인해 로컬 VCS 라는 것을 만들었고, 아주 간단한 데이터베이스를 사용해서 파일의 변경 정보를 관리했다.

**RCS(Revision Control System)**
: VCS 도구 중에 하나로 오늘날까지도 아직 많은 회사가 사용하고 있다
RCS는 기본적으 Patch Set(파일에서 변경되는 부분)을 관리한다.

이 Patch Set 은 특별한 형식의 파일로 저장한다. 그리고 일련의 Patch Set을 적용해서 모든 파일을 특정 시점으로 되돌릴 수 있다.

#### 중앙집중식 버전 관리)

프로젝트를 진행하다 보면 다른 개발자와 함께 작업해야하는 경우가 생겨난다. 이럴 때 생기는 문제를 해결하기 위해 CVCS(중앙집중식 VCS)가 개발되었다.

CVS, Subversion, Perforce 같은 시스템은 파일을 관리하는 서버가 별도로 있고 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)한다.

CVCS 환경은 로컬VCS 에 비해 장점이 많다. 모두 누가 무엇을 하고 있는지 알 수 있으며, 관리자는 누가 무엇을 할지 꼼꼼하게 관리할 수 있다.

모든 클라이언트의 로컬 데이터베이스를 관리하는 것보다 VCS 하나를 관리하기가 훨씬 쉽다.

**CVCS의 단점**

1. 만약 서버가 일정시간 동안 다운되면 그동안 아무도 다른 사람과 협업을 할 수 없고 사람들이 하는 일을 백업할 방법도 없다.

2. 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃는다.

#### 분산 버전 관리 시스템)

DVCS(분산VCS)는 Git, Mecurial, Bazaar, Darcs 같은 DVCS에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout 하지 않는다. 그냥 저장소를 히스토리와 더불어 전부 복제한다.

이러한 방법은 서버에 문제가 생기면 이 복제물로 다시 작업을 시작할 수 있으며 클라이언트 중에서 아무거나 골라도 서버를 복월할 수 있다.

Clone은 모든 데이터를 가진 진정한 백업이다.

게다가 대부분의 DVCS 환경에서는 리모트 저장소가 존재하는데 사람들은 동시에 다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델 같은 중앙 집중식 시스템으로는 할 수 없는 워크플로를 다양하게 사용할 수 있다.

[출처](https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%B2%84%EC%A0%84-%EA%B4%80%EB%A6%AC%EB%9E%80%3F) Git

# Java 자료형(Type)

#### 숫자 (Number)

**정수)**

Java 에서 정수를 표현하기 위한 Type 은 **int**, **long**이 있다.

int와 long의 차이 (**표현 범위의 차이다.**)

| 자료형(Type) | 표현범위                                   |
| ------------ | ------------------------------------------ |
| int          | -2147483648 ~ 2147483647                   |
| long         | -9223372036854775808 ~ 9223372036854775807 |

> long 변수에 값을 대입할 때는 대입하는 숫자 값이 int 자료형의 최대값인 2147483647 보다 큰 경우 `8764827384923849L`과 같이 `L` 접미사(또는 소문자 `l`, 소문자 'l'은 숫자 1과 비슷하게 보이므로 추천하지 않는다.)를 붙여 주어야 한다. 만약 'L'과 같은 접미사를 누락하면 컴파일 에러가 발생한다.

**실수)**

Java 에서 실수를 표현하기 위한 Type 은 **float**, **double** 이다.

이 또한 역시 표현범위의 차이다.

> 자바에서 실수형은 디폴트가 double이므로 위의 예에서 보듯이 float 변수에 값을 대입할 때에는 3.14F 와 같이 `F`접미사(또는 소문자 `f`)를 꼭 붙여 주어야 한다. float 자료형에 값을 대입할 때 접미사를 누락하면 컴파일 에러가 발생한다.

과학적 지수 표현식

```java
double a = 123.4;
double b = 1.234e2;
```

위 a와 b 는 같은 값이 된다.

그 이유는 b의 e2 는 10의 제곱을 의미하기 때문이다.

**숫자연산)**

- **+** (덧셈)
- **-** (뺄셈)
- **\*** (곱셈)
- **/** (나눗셈)
- **%** (나머지)

_Test.java_

```java
public class Test {
	public static void main(String[] args){
		int a = 7;
		int b = 3;
		System.out.println(a+b);
		System.out.println(a-b);
		System.out.println(a*b);
		System.out.println(a/b);
		System.out.println(a%b);
	}
}
```

위 자바 프로그램을 실행시키면 다음과 같은 결과가 나온다.

```
10
4
21
2
1
```

**증감연산)**

Java는 `++`, `--` 기호를 이용하여 값을 증가하거나 감소시킬 수 있다.

_Test.java_

```java
public class Test {
	public static void main(String[] args){
		int a = 7;
		int b = 3;
		System.out.println(a++);
		System.out.println(b--);
	}
}
```

```
8
2
```

와 같은 결과가 나온다.

이 연산자는 위치에 따라 결과가 다르기 때문에 주의해야한다.

다음 예제를 보자

_Test.java_

```java
public class Test {
	public static void main(String[] args){
		int a = 0;
		System.out.println(a++);
		System.out.println(a);
	}
}
```

실행 결과

```
0
1
```

> `System.out.println(a++)` 의 출력값은 a가 1만큼 증가되어 1 이 출력되어야 할 것 같지만 0 이 출력되었다. 그렇다면 변수 i의 값이 증가되지 않은것일까? 그 다음 문장인 `System.out.println(a)` 의 출력값을 확인 해 보니 1이 나온다. 그렇다면 a의 값이 증가는 된 것이다.
>
> 이런 결과가 나오는 원인은 변수 `++` 연산자의 위치 때문이다. 즉 `a++` 와 같이 ++ 연산자가 변수명 뒤에 붙으면 해당 코드가 실행되는 순간에는 a 값이 변경되지 않는다. 다만 `a++` 문장이 실행된 이후에 a값이 증가하게 된다. 이와는 반대로 `a++` 대신 `++a`라고 사용하게 되면 a 값이 먼저 증가된 후에 해당 코드가 실행된다.
>
> - `a++` : 값이 참조된 후에 증가
> - `++a` : 값이 참조되기 전에 증가

_Test.java_

```java
public class Test {
	public static void main(String[] args){
		int a = 0;
		System.out.println(++a);
		System.out.println(a);
	}
}
```

실행 결과

```
1
1
```

> `++a` 에 의해서 a값이 먼저 증가되는 것을 확인 할 수 있다.
>
> `--` 연산자도 `++` 연산자와 동일한 규칙을 따른다.

[출처](https://wikidocs.net/204) 점프 투 자바
